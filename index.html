<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>sonemeen22博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="开发，C++工程师">
<meta name="keywords" content="C++，算法，机器学习">
<meta property="og:type" content="website">
<meta property="og:title" content="sonemeen22博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="sonemeen22博客">
<meta property="og:description" content="开发，C++工程师">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="sonemeen22博客">
<meta name="twitter:description" content="开发，C++工程师">
  
    <link rel="alternate" href="/atom.xml" title="sonemeen22博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">sonemeen22博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技术博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Google-S2" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/14/Google-S2/" class="article-date">
  <time datetime="2019-02-14T03:30:10.000Z" itemprop="datePublished">2019-02-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/14/Google-S2/">Google S2文档翻译</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>Overview<br>S2 is a library for spherical geometry that aims to have the same robustness, flexibility, and performance as the very best planar geometry libraries.</p>
<p>S2是一个基于球面几何的库，目标是和相当出色的平面几何库拥有相同的鲁棒性、可伸缩性、性能。</p>
<p>Spherical Geometry<br>Let’s break down the elements of this goal. First, why spherical geometry? (By the way, the name “S2” is derived from the mathematical notation for the unit sphere, S².)<br>Traditional cartography is based on map projections, which are simply functions that map points on the Earth’s surface to points on a planar map. Map projections create distortions due to the fact that the shape of the Earth is not very close to the shape of a plane. For example, the well-known Mercator projection is discontinuous along the 180 degree meridian, has large scale distortions at high latitudes, and cannot represent the north and south poles at all. Other projections make different compromises, but no planar projection does a good job of representing the entire surface of the Earth.</p>
<p>让我们划分下这个目标的模块。首先，为什么是球面几何？（顺便提示，“S2”这个名字是派生自数学符号单位球体，S²。）传统的制图学是根据地图投影，这是简单地映射地球表面的点到一张平面地图上。由于地球的形状并不是非常接近平面，地图投影会产生误差。例如，著名的墨卡托投影沿着180度的子午线是不连续的，在高纬度有着大规模的扭曲，并且不能代表北极、南极。其他的投影产生不同的折中，但是没有平面投影在表示整个地表方面做得好。</p>
<p>S2 approaches this problem by working exclusively with spherical projections. As the name implies, spherical projections map points on the Earth’s surface to a perfect mathematical sphere. Such mappings still create some distortion, of course, because the Earth is not quite spherical–but as it turns out, the Earth is much closer to being a sphere than a plane. With spherical projections, it is possible to approximate the entire Earth’s surface with a maximum distortion of 0.56%. Perhaps more importantly, spherical projections preserve the correct topology of the Earth – there are no singularities or discontinuities to deal with.</p>
<p>首先，为什么是球面几何？S2通过唯一地使用球面投影解决了这个问题。正如名字所示，球面投影将地球表面的点映射到一个完好的数学球体。这样的映射仍然会产生误差，当然因为地球不是非常地接近球体。但是事实证明，地球是更加接近是一个球体而不是一个平面。通过球面映射，可能可以近似模拟整个地表而最多产生0.56%的误差。更重要的是，球面投影保留准确的地球拓扑。没有奇点和不连续性需要处理。</p>
<p>Why not project onto an ellipsoid? (The Earth isn’t quite ellipsoidal either, but it is even closer to being an ellipsoid than a sphere.) The answer relates to the other goals stated above, namely performance and robustness. Ellipsoidal operations are still orders of magnitude slower than the corresponding operations on a sphere. Furthermore, robust geometric algorithms require the implementation of exact geometric predicates that are not subject to numerical errors. While this is fairly straightforward for planar geometry, and somewhat harder for spherical geometry, it is not known how to implement all of the necessary predicates for ellipsoidal geometry.</p>
<p>为什么不投影到一个椭球？（地球也不是完全的椭球体。但是实际上比起球体它是更加接近椭球体。）答案关联到以上提到的其他目标，性能和鲁棒性。椭球体上的操作仍然比球体上的操作慢几个数量级。此外，鲁棒性的几何算法需要实现不受数字误差影响的精确几何谓词。虽然这对于平面几何来说非常简单，而对于球面几何来说有些困难，都不知道如何为椭球体几何实现所有的几何谓词。</p>
<h2 id="S2-Cells"><a href="#S2-Cells" class="headerlink" title="S2 Cells"></a>S2 Cells</h2><p>The S2 library defines a framework for decomposing the unit sphere into a hierarchy of cells. Each cell is a quadrilateral bounded by four geodesics. The top level of the hierarchy is obtained by projecting the six faces of a cube onto the unit sphere, and lower levels are obtained by subdividing each cell into four children recursively. For example, the following image shows two of the six face cells, one of which has been subdivided several times:<br>S2库为了分解一个单位球体为一个分层的cells定义了一个框架。每一个cell是一个由四个测地线限定的四边形。通过将立方体的六个面投影到单位球上来获得这个层次结构的顶层，低层结构则通过递归地切分每个cell为4个子块来获得。例如，以下图片展示了6个面cell的其中2个cell，其中1个已经切分了多次：</p>
<p>Notice that the cell edges appear to be curved; this is because they are spherical geodesics, i.e., straight lines on the sphere (similar to the routes that airplanes fly).<br>注意cell的边缘是弯曲的；这是因为它们是球形测地线，例如球体上的直线（和飞行航线类似）。</p>
<p>Each cell in the hierarchy has a level, defined as the number of times the cell has been subdivided (starting with a face cell). Cells levels range from 0 to 30. The smallest cells at level 30 are called leaf cells; there are 6 * 430 of them in total, each about 1cm across on the Earth’s surface. (Details on the cell sizes at each level can be found on the S2 Cell Statistics page.)</p>
<p>在这个层次结构中，每个cell都有一个level，定义是这个cell已经被切分的次数（从最顶层的cell开始）。cell的level范围从0到30。最小的cell是level 30的cell，称为leaf cells。它们总共有6 * 4的30次方个，每个是地表上的1厘米。（详细的关于cell各个层级的尺寸请参照这个链接。）</p>
<p>The S2 hierarchy is useful for spatial indexing and for approximating regions as a collection of cells. Cells can be used to represent both points and regions: points are generally represented as leaf cells, while regions are represented as collections of cells at any level(s). For example, here is an approximation of Hawaii as a collection of 22 cells:<br>S2层次结构对于空间索引和划分地区为一个cells的集合是有用的。cells可以用于表示点和区域：点通常表示为叶子cells，而区域是表示为任何层次的cells的集合。例如，这是一个夏威夷作为22个cell的划分：</p>
<p>S2CellId Numbering<br>Each cell is uniquely identified by a 64-bit S2CellId. The S2 cells are numbered in a special way in order to maximize locality of reference when they are used for spatial indexing (compared to other methods of numbering the cells).</p>
<p>每个cell是独立地标志为一个64位的S2CellId。S2 cells以特殊方式编号，以便在用于空间索引时最大化参考的位置（与其他编号cell的方法相比）。</p>
<p>In particular, the S2 cells are ordered sequentially along a space-filling curve (a type of fractal). The particular curve used by S2 is called the S2 space-filling curve, and consists of six Hilbert curves linked together to form a single continuous loop over the entire sphere. Here is an illustration of the S2 curve after 5 levels of subdivision:</p>
<p>特别地，S2 cell沿着空间填充曲线（一种分形）顺序排列。这个由S2使用的特别的曲线称为S2空间填充曲线，由连接在一起的六条希尔伯特曲线组成，在整个球体上形成一个连续的环。以下是5级细分后的S2曲线图示：</p>
<p>The yellow curve is an approximation of the S2 space-filling curve. It is a single continuous loop with a fractal structure such that it passes near every point on the sphere. (If you were to cut along the yellow line, it would separate the sphere into two equal halves.) The green lines show the boundaries of the S2 cells at levels 0, 1, 2, 3, 4, and 5, drawn as lines of different widths. (You can click on the image to see a larger version.)</p>
<p>黄色曲线是一个S2空间填充曲线的划分。它是一个单调递增的环，伴随着一个不规则碎片形结构从而让它穿过球体上的每一个点。（如果我你可以沿着黄线切断，将会把球体分为两等分。）这些不同宽度的绿色的线展示了S2 cells在level 0, 1, 2, 3, 4和5的边界。（你可以点击这个图片去看更大的版本。）</p>
<p>The cells at level 5 are numbered in increasing order along this curve. This leads to the property that if the S2CellIds of two cells are close together, then the cells are also close together.1 This property significantly improves locality of reference when the cells are used for indexing.</p>
<p>level 5的cells通过沿着这条曲线的递增的序列编号。这引出一个性质如果两个cells的S2CellIds是接近的，然后这些cells也是接近的。当cells用于建立索引，这条性质显著地改进了参照的局部性。</p>
<p>The remainder of this section gives further details about how the S2 cell hierarchy is organized. (You don’t need to understand this background information in order to use the library – you can skip forward if desired.)</p>
<p>本节的其余部分提供了有关如何组织S2单元层次结构的更多详细信息。</p>
<p>Hilbert Curve<br>The S2 curve is based on the Hilbert curve. The Hilbert curve is a function from the unit interval [0,1] to the unit square [0,1]×[0,1] that is space-filling, meaning that it visits every point in the unit square. The Hilbert curve is continuous but not differentiable, and can be considered to have infinite length.</p>
<p>S2曲线是基于希尔伯特曲线。希尔伯特曲线是一个函数从单元线段[0,1]到单元方格[0,1]×[0,1]<br>称为空间填充，意味着它将访问单位球体的每一个点。希尔伯特曲线是连续的但是不可微。并能设想为具有无限的长度。</p>
<p>It is most easily defined as the limit of an iterative process that builds a more detailed approximation of the curve at each step. Here is a part of the first page of Hilbert’s 1891 paper defining his curve (cf.Mark McClure ):</p>
<p>一步步地构建一个更加详细的曲线划分的迭代过程的限制是非常简单的定义。这是论文的第一页的一个部分。</p>
<p>As you can see, the first iteration divides the unit square into 4 smaller squares. The curve visits those squares in a particular order that looks like an inverted “U” (figure 1). The second iteration takes each square from the first iteration and divides it into 4 smaller subsquares. The curve again visits those subsquares in a U-shaped order, except that some of the U-shapes have been rotated and/or reflected in order to link the curves together seamlessly (figure 2). (The rotation/reflection rules are simple but we will not describe them here.) Figure 3 shows the result after three iterations.</p>
<p>正如你能看到的，第一次迭代划分这个单位方块为4个更小的方块。这个曲线按照一定的顺序，看上去像一个反转的“U”，访问这些方块。第二次迭代从第一次迭代中取出每个方块，然后划分它为4个更小的子方块。这个曲线按照U形顺序再次访问这些子方块，除了一些U形已经被翻转或者反射来连接曲线到一块。（翻转、反射规则很简单但是我们将不会在这里描述。）图3展示了三次迭代的结果。</p>
<p>How does this process define a mapping from the unit interval to the unit square? Let<br>H : [0,1] → [0,1] × [0,1]<br>be the Hilbert curve, and suppose that we want to evaluate H(s) for the real number s = 0.5. We start by writing out the binary expansion of s = 0.5:<br>s = 0.100000000…<br>To find the corresponding point H(s) on the Hilbert curve, we group the digits of “s” into pairs:<br>[10, 00, 00, 00, …]</p>
<p>这个过程如何定义一个从单位线段到单位方块的映射？想让：<br>H : [0,1] → [0,1] × [0,1]<br>成为希尔伯特曲线，假设我们想为实数s=0.5估算H(s)的值。我们从写出s=0.5的二进制扩展开始：<br>s = 0.100000000…<br>为了找到相应的点，我们将”s”的位划分为多对：<br>[10, 00, 00, 00, …]</p>
<p>Each pair of binary digits corresponds to a decimal number between 0 and 3, and indicates which of the 4 subsquares to choose at each step of the construction process. Note that unlike Hilbert’s paper, we number the subsquares of each square from 0 to 3 (in the order they are visited by the curve) rather than 1 to 4. For example, in the case of s = 0.5, the first group of digits “10” corresponds to the decimal number 2, which means that we choose subsquare 2 during the first iteration (i.e., square 3 in Hilbert’s figure 1). The next group of digits is “00”, meaning that we choose subsquare 0 during the second iteration (corresponding to square 9 in Hilbert’s figure 2). Continuing in this way, for s = 0.5 the result looks something like this:</p>
<p>每一对二进制数位对应一个0-3的十进制数字。表示4个子方块在构建的每一步如何选择。注意，不像希伯尔特的论文，我们从0到3编号每一个方块（按照它们在曲线上被访问的顺序）而不是从1到4。例如，s=0.5的情况，第一组数位“10”对应十进制数字2，表示在第一次迭代中我们选择子方块2（如图1的方块3）。下一组数位是“00”，意味着第二次迭代中我们选择子方块0（对应图2的方块9）。继续这个过程，对于s=0.5的结果将是如此：</p>
<p>In the limit, this process converges to a point that is exactly at the center of the square (the green dot in the figure). This implies that<br>H(0.5) = (0.5, 0.5)<br>i.e., the midpoint of the Hilbert curve is at the exact center of unit square.2 The value of H(s) for any real number “s” can be evaluated using a similar process.</p>
<p>在这个限制中，这个过程转换为一个准确地位于方格中心的点（图中的绿点）。这表明：<br>H(0.5) = (0.5, 0.5)<br>例如，希伯尔特曲线的中点是方块2的中心。对于任何实数s，H(s)的值可以使用相同的过程估算。</p>
<p>S2 Space-Filling Curve<br>The S2 space-filling curve is a function<br>S : [0,6] → S²<br>i.e., from the interval [0,6] to the unit sphere. It is constructed by mapping 6 copies of the Hilbert curve to the 6 faces of a unit cube, reflecting and rotating the curves as necessary so that that they link together seamlessly into a continuous loop. The cube is then mapped to the unit sphere using a transformation that minimizes distortion.<br>We can view the S2 curve parameter “s” as having the format:<br>s = [face].[face_pos]<br>where “face” is a number in the range [0..5] that selects one of the six cube faces, and “face_pos” is the Hilbert curve parameter on that face. This mapping is defined such that the end of the curve on face i exactly matches the start of the curve on face i+1 (including the transition from face 5 to face 0).<br>Here is an illustration (not fully accurate, but conceptually correct) of the S2 curve on the unit cube (before projecting it to the sphere). The cube has been unfolded and flattened, and shows the first 4 levels of the S2 curve subdivision:</p>
<p>S2空间填充曲线是一个函数：<br>S : [0,6] → S²<br>例如，从线段[0,6]到单元球。通过映射希伯尔特曲线到单位立方体的6个面的6份拷贝，反射和翻转曲线以此它们能无缝地连接在一起成为一个连续的环。然后立方体通过使用最小化失真转换映射到单位球体。我们能按照如下格式访问S2曲线的参数“s”：<br>s = [face].[face_pos]<br>面是0-5的数字，选择立方体6个面的其中之一。“face_pos” 是希伯尔特曲线在这个面的参数。这个映射定义为在面i曲线的末端准确地匹配面i+1的曲线起始位置（包括从面5到面0的转变）。<br>这是一个S2曲线在单位立方体（在将它投影到球体上）上的插图（不完全准确的，但是概念上是对的）。立方体已经展开并展平，展示了S2曲线的level 4划分：</p>
<p>(Larger images of the individual faces can be found here.) Note that the traversal order of the odd-numbered faces is the mirror image of the even-numbered faces.<br>When the cube is mapped onto the unit sphere, the result is the curve shown earlier:<br>（更大的独立的面的图片可以在这里找到。）注意，遍历顺序中奇数面是偶数面的反射。当立方体映射为单位球体，结果如之前展示的那样：</p>
<p>S2CellId Numbering (again)<br>We now return to the question of how the S2 cells are numbered. Recall that there are 31 levels of subdivision, ranging from 0 to 30. It turns out that the cell numbering system at all levels follows a very simple rule, namely:<br>The S2CellId of cell C is the S2 curve parameter at the center of C (scaled to obtain an integer).<br>For example, consider the level 0 cell for cube face 2. The center of this cell has the S2 curve parameter (in binary):<br>s = 010.100000000…<br>where “010” is the binary representation of face 2 and “.1000…” is the binary representation of 0.5 (i.e., the Hilbert curve parameter at the center of this face, as discussed above). Scaling this by a factor of 261, we obtain 0101000… in binary (where there are 60 trailing zeros), or 0x5000000000000000 in hexadecimal. This is the S2CellId for the level 0 cell on face 2.</p>
<p>我们现在回到S2 cells如何编号的问题上。召回划分的31个level，从0到30。事实证明cell的编号系统在各个level遵循一个非常简单的规则，即：<br>cell C的S2CellId是S2曲线在C的中心参数（以此获得一个整数）。<br>例如，考虑立方体face 2的level 0 cell。这个cell的中心有S2曲线参数（二进制）：<br>s = 010.100000000…<br>“010”是二进制表示face 2，而“.1000…”是0.5的二进制形式（例如，正如上面所述，在这个面的中心的希尔伯特曲线参数）。将其缩放261倍，我们得到0101000…（有60个尾随零），或者十六进制0x5000000000000000。这是face 2的level 0 cell的S2CellId。</p>
<p>It turns out that all S2CellIds up to level 30 can be represented in this way, i.e. the S2 curve parameters of the corresponding cell centers can be represented exactly in 64 bits. Note that no two cells (even at different levels) have the same center position, and therefore all the S2CellIds are distinct. The cell center is sufficient to specify both the position and the subdivision level of each cell.<br>We can also look at this from a more practical point of view. The S2CellId for a cell at level k always has the following structure:<br>s = [face] [child]k 1 060-2k<br>where “face” is a 3-bit number (range 0..5) that selects a cube face, and each of the k “child” values is a 2-bit number that selects one of the 4 children during the subdivision process. The bit that follows the last child is always 1, and all other bits are zero. For example:</p>
<p>事实证明上至level 30的所有S2CellIds能按照这个方式表示。例如对应cell中心的S2曲线参数能准确地表示为64位数字。注意，没有两个cells（甚至是不同level的）有着相同中心。所以所有的S2CellIds是唯一的。cell的中心足够指定每一个cell的位置和层级划分。<br>我们也可以从更实际的角度来看待这个问题。在level k的cell的S2CellId总是这样的结构：<br>s = [face] [child]k 1 060-2k<br>“face” 是3比特的数字（0-5）以此选择一个立方体的面，每一个k的“child”值是一个2比特的数字以此在划分过程中选择4个子cells中的其中一个。最后一个孩子的bit总是1，所有其他的比特是0。例如：<br>010 10000…0         Face cell 2.<br>001 10 100…0        Subcell 2 of face cell 1.<br>100 11 01 1000…0    Subcell 1 of subcell 3 of face 4.</p>
<p>This representation has the convenient property that the subdivision level of a cell can easily be determined from the position of its lowest-numbered 1 bit.</p>
<p>这种表示对于划分一个cell的level能简单地定义为它的最小数位1比特的位置很方便。</p>
<p>Coordinate Systems<br>The process of mapping an S2CellId to a point on the unit sphere involves several steps, each with its own coordinate system.<br>映射一个S2CellId到一个单位球体的点的过程包含着若干步骤，每一个都它自己的坐标系。</p>
<p>(cellid)<br>Cell id: A 64-bit encoding of a face and a Hilbert curve parameter on that face, as discussed above. The Hilbert curve parameter implicitly encodes both the position of a cell and its subdivision level.</p>
<p>cellid<br>Cell id：正如以上所述，是一个1个face和1个那个面的希尔伯特曲线参数的64位的编码。希尔伯特曲线参数暗中编码了一个cell的位置和它的划分层级。</p>
<p>(face, i, j)\ Leaf-cell coordinates: The leaf cells are the subsquares that result after 30 levels of Hilbert curve subdivision, consisting of a 230 × 230 array on each face. “i” and “j” are integers in the range [0, 230-1] that identify a particular leaf cell. The (i, j) coordinate system is right-handed on every face, and the faces are oriented such that Hilbert curves connect continuously from one face to the next.</p>
<p>(face, i, j)\叶子cell的坐标：叶子cell是希伯尔特曲线30个level划分后产生的子块。包含一个230x230的数组。i和j是一个范围是[0, 230-1]的整数，唯一地表示一个特定的叶子cell。(i,j)坐标系是右手坐标系。face是毗邻的，以致于希伯尔特曲线连续地连接每一个面。</p>
<p>(face, s, t)\ Cell-space coordinates: “s” and “t” are real numbers in the range [0,1] that identify a point on the given face. For example, the point (s, t) = (0.5, 0.5) corresponds to the center of the cell at level 0. Cells in (s, t)-coordinates are perfectly square and subdivided around their center point, just like the Hilbert curve construction.</p>
<p>(face, s, t)\cell-空间坐标：s和t是范围0-1的实数表示一个给定的face的一个点。例如，点(s,t)=(0.5,0.5)对应level 0的cell的中心。cell在(s,t)-坐标是完全正方形的和划分他们的中心点，正如希伯尔特曲线构建过程那样。</p>
<p>(face, u, v)\ Cube-space coordinates: To make the cells at each level more uniform in size after they are projected onto the sphere, we apply a nonlinear transformation of the form u=f(s), v=f(t) before projecting points onto the sphere. This function also scales the (u,v)-coordinates so that each face covers the biunit square [-1,1]×[-1,1]. Cells in (u,v)-coordinates are rectangular, and are not necessarily subdivided around their center point (because of the nonlinear transformation “f”).</p>
<p>范围(face, u, v)\ 立方体空间坐标系：为了让每个level的cells在它们投影到球面上后，尺寸上更加统一，在投影点到球面之前，我们申请一个以u=f(s), v=f(t)的形式的非线性转换。这个函数也缩放(u,v)-坐标系从而每一个face覆盖单位正方形[-1,1]×[-1,1]。cells的(u,v)-坐标是矩形的，并且不一定围绕它们的中心点细分</p>
<p>(x, y, z)\ Spherical point: The final S2Point is obtained by projecting the (face, u, v) coordinates onto the unit sphere. Cells in (x,y,z)-coordinates are quadrilaterals bounded by four spherical geodesic edges.</p>
<p>(x, y, z)\球面点：最后的S2Point是通过投影(face, u, v)坐标到单位球体。(x, y, z)的cell坐标系是由四个球形测地边界限定的四边形。</p>
<p>The purpose of the nonlinear (face, s, t) → (face, u, v) transformation is to make the cells roughly the same size on the sphere. This can be visualized as follows:</p>
<p>(face, s, t) → (face, u, v)的非线性转换的目的是为了让cells在球体上有着同样的大小。这个转换如下展示：</p>
<p>{height=”400”}<br>This diagram shows a one-dimensional slice of cube face. Starting from the right-hand size, an s- or t-coordinate in the range [0,1] is transformed non-linearly into a u- or v-coordinate in the range [-1,1]. This point is then projected onto the unit sphere.<br>The purpose of the (face, s, t)→(face, u, v) transformation is illustrated by the two angles marked in red. Although both angles are the same size, and therefore correspond to the same distance on the unit sphere, they have very different sizes when projected back to (u,v)-coordinates (i.e., the top interval on the middle (u,v)-slice is much larger). The non-linear transformation between (s,t) and (u,v) coordinates helps to correct this situation (i.e., the intervals on the right-hand (s,t)-slice are closer in size).<br>Note that the (i, j), (s, t), and (u, v) coordinate systems are right-handed on all six faces.</p>
<p>这个图表展示了一个一维的立方体face的分片。从右手坐标系的尺寸开始，一个范围0-1是s或者t的坐标通过非线性转换转换为范围是[-1,1]的u v坐标。然后这个点投影到单位球体。<br>(face, s, t) → (face, u, v)的转换目的是如图解所示的2个红色标出的角。虽然两个角有着相同的大小，对应着单位球体的相同距离。但是当投影回(u,v)坐标，他们有着非常不同的尺寸。（例如，最顶层的在(u,v)中间分片的线段是要大得多）。(s,t) 和 (u,v)的非线性转换有益于矫正这个条件。（例如，右手坐标(s,t)分片更接近这个尺寸）。<br>注意，(i, j), (s, t)和(u,v)坐标系在6个面是右手坐标系。</p>
<p>S2CellId<br>The S2CellId class is a thin wrapper over the 64-bit S2CellId number that provides methods for navigating the cell hierarchy (finding parents, children, containment tests, etc). Since leaf cells are often used to represent points on the unit sphere, the S2CellId class also provides methods for converting directly to and from an S2Point. Here are its methods:</p>
<p>S2CellId类是一个薄包装的64位S2CellId数字，为导航cell层次结构（查找父母cell和孩子cell的包含测试）提供方法。叶cell经常用于表示球面的点，S2CellId类也提供将S2Point直接转换的方法。这是它的方法：</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/14/Google-S2/" data-id="cjs4gco140002ia68skmomuts" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-B树" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/28/B树/" class="article-date">
  <time datetime="2019-01-28T02:26:19.000Z" itemprop="datePublished">2019-01-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/28/B树/">B树-C++实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>代码链接：<a href="https://github.com/sonemeen22/BTree" target="_blank" rel="noopener">BTree</a></p>
<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><h3 id="插入性能"><a href="#插入性能" class="headerlink" title="插入性能"></a>插入性能</h3><p>插入性能测试：<br>t=10的情况下（t是最小度）<br>1000个数字<br>1K<br>Time taken: 0.001019s<br>1.019ms</p>
<p>BTree&lt;int, int, 10&gt;<br>10000个数字<br>1W<br>[0,10000)的范围<br>Time taken: 0.003248s<br>3.248ms</p>
<p>BTree&lt;int, int, 10&gt;<br>100000个数字<br>10W<br>[0,100000)的范围<br>Time taken: 0.049264s<br>49.264ms</p>
<p>BTree&lt;int, int, 10&gt;<br>1000000个数字<br>100W<br>[0,1000000)的范围<br>Time taken: 0.610387s<br>610.387ms</p>
<p>BTree&lt;int, int, 10&gt;<br>10000000个数字<br>1000W<br>[0,10000000)的范围<br>Time taken: 8.897854s<br>8897ms</p>
<p>BTree&lt;int, int, 10&gt;<br>100000000个数字<br>1亿<br>[0,100000000)的范围<br>Insert time taken: 150.170929s</p>
<h3 id="查询性能"><a href="#查询性能" class="headerlink" title="查询性能"></a>查询性能</h3><p>B树：<br>BTree&lt;int, int, 10&gt;</p>
<p>10W个数字<br>[0,100000)的范围<br>Search time taken: 0.031458s<br>31.458ms</p>
<p>100W个数字<br>[0,1000000)的范围<br>Insert time taken: 0.646902s<br>Search time taken: 0.429090s<br>429ms</p>
<p>1000W个数字<br>[0,10000000)的范围<br>Insert time taken: 8.728024s<br>Search time taken: 8.611078s<br>8611ms<br>单次耗时：0.0008611ms<br>Search time taken: 0.00000200s<br>0.00200ms</p>
<p>BTree&lt;int, int, 10&gt;<br>100000000个数字<br>查询：1亿个数字<br>索引key的数目：1亿个数字<br>[0,100000000)的范围<br>Search time taken: 168.00914900s<br>168009ms<br>0.00168009ms</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/28/B树/" data-id="cjs4gco0y0001ia68y4g13vu4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/28/hello-world/" class="article-date">
  <time datetime="2019-01-27T16:20:35.072Z" itemprop="datePublished">2019-01-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/28/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/28/hello-world/" data-id="cjs4gco000000ia685pjh0o9t" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/02/14/Google-S2/">Google S2文档翻译</a>
          </li>
        
          <li>
            <a href="/2019/01/28/B树/">B树-C++实现</a>
          </li>
        
          <li>
            <a href="/2019/01/28/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 小益<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>