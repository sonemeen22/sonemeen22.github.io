<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false,"dimmer":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="概览OverviewS2 is a library for spherical geometry that aims to have the same robustness, flexibility, and performance as the very best planar geometry libraries. S2是一个基于球面几何的库，目标是和相当出色的平面几何库拥有相同的鲁棒性、可伸">
<meta name="keywords" content="C++，算法，机器学习">
<meta property="og:type" content="article">
<meta property="og:title" content="Google S2文档翻译">
<meta property="og:url" content="http://yoursite.com/2019/02/14/Google-S2/index.html">
<meta property="og:site_name" content="sonemeen22博客">
<meta property="og:description" content="概览OverviewS2 is a library for spherical geometry that aims to have the same robustness, flexibility, and performance as the very best planar geometry libraries. S2是一个基于球面几何的库，目标是和相当出色的平面几何库拥有相同的鲁棒性、可伸">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/2019/02/14/Google-S2/images/s2hierarchy.gif">
<meta property="og:image" content="http://yoursite.com/2019/02/14/Google-S2/images/hawaii.gif">
<meta property="og:image" content="http://yoursite.com/2019/02/14/Google-S2/images/s2curve-small.gif">
<meta property="og:image" content="http://yoursite.com/2019/02/14/Google-S2/images/hilbert-figure.gif">
<meta property="og:image" content="http://yoursite.com/2019/02/14/Google-S2/images/hilbert-cell-center.gif">
<meta property="og:image" content="http://yoursite.com/2019/02/14/Google-S2/images/s2curve-tiny.gif">
<meta property="og:image" content="http://yoursite.com/2019/02/14/Google-S2/images/xyz_to_uv_to_st.gif">
<meta property="og:updated_time" content="2019-02-20T09:34:11.107Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Google S2文档翻译">
<meta name="twitter:description" content="概览OverviewS2 is a library for spherical geometry that aims to have the same robustness, flexibility, and performance as the very best planar geometry libraries. S2是一个基于球面几何的库，目标是和相当出色的平面几何库拥有相同的鲁棒性、可伸">
<meta name="twitter:image" content="http://yoursite.com/2019/02/14/Google-S2/images/s2hierarchy.gif">






  <link rel="canonical" href="http://yoursite.com/2019/02/14/Google-S2/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Google S2文档翻译 | sonemeen22博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">sonemeen22博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">技术博客</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/14/Google-S2/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小益">
      <meta itemprop="description" content="开发，C++工程师">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sonemeen22博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Google S2文档翻译

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-14 11:30:10" itemprop="dateCreated datePublished" datetime="2019-02-14T11:30:10+08:00">2019-02-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-02-20 17:34:11" itemprop="dateModified" datetime="2019-02-20T17:34:11+08:00">2019-02-20</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>Overview<br>S2 is a library for spherical geometry that aims to have the same robustness, flexibility, and performance as the very best planar geometry libraries.</p>
<p>S2是一个基于球面几何的库，目标是和相当出色的平面几何库拥有相同的鲁棒性、可伸缩性、性能。</p>
<p>Spherical Geometry<br>Let’s break down the elements of this goal. First, why spherical geometry? (By the way, the name “S2” is derived from the mathematical notation for the unit sphere, S².)<br>Traditional cartography is based on map projections, which are simply functions that map points on the Earth’s surface to points on a planar map. Map projections create distortions due to the fact that the shape of the Earth is not very close to the shape of a plane. For example, the well-known Mercator projection is discontinuous along the 180 degree meridian, has large scale distortions at high latitudes, and cannot represent the north and south poles at all. Other projections make different compromises, but no planar projection does a good job of representing the entire surface of the Earth.</p>
<p>让我们划分下这个目标的模块。首先，为什么是球面几何？（顺便提示，“S2”这个名字是派生自数学符号单位球体，S²。）传统的制图学是根据地图投影，这是简单地映射地球表面的点到一张平面地图上。由于地球的形状并不是非常接近平面，地图投影会产生误差。例如，著名的墨卡托投影沿着180度的子午线是不连续的，在高纬度有着大规模的扭曲，并且不能代表北极、南极。其他的投影产生不同的折中，但是没有平面投影在表示整个地表方面做得好。</p>
<a id="more"></a>
<p>S2 approaches this problem by working exclusively with spherical projections. As the name implies, spherical projections map points on the Earth’s surface to a perfect mathematical sphere. Such mappings still create some distortion, of course, because the Earth is not quite spherical–but as it turns out, the Earth is much closer to being a sphere than a plane. With spherical projections, it is possible to approximate the entire Earth’s surface with a maximum distortion of 0.56%. Perhaps more importantly, spherical projections preserve the correct topology of the Earth – there are no singularities or discontinuities to deal with.</p>
<p>首先，为什么是球面几何？S2通过唯一地使用球面投影解决了这个问题。正如名字所示，球面投影将地球表面的点映射到一个完好的数学球体。这样的映射仍然会产生误差，当然因为地球不是非常地接近球体。但是事实证明，地球是更加接近是一个球体而不是一个平面。通过球面映射，可能可以近似模拟整个地表而最多产生0.56%的误差。更重要的是，球面投影保留准确的地球拓扑。没有奇点和不连续性需要处理。</p>
<p>Why not project onto an ellipsoid? (The Earth isn’t quite ellipsoidal either, but it is even closer to being an ellipsoid than a sphere.) The answer relates to the other goals stated above, namely performance and robustness. Ellipsoidal operations are still orders of magnitude slower than the corresponding operations on a sphere. Furthermore, robust geometric algorithms require the implementation of exact geometric predicates that are not subject to numerical errors. While this is fairly straightforward for planar geometry, and somewhat harder for spherical geometry, it is not known how to implement all of the necessary predicates for ellipsoidal geometry.</p>
<p>为什么不投影到一个椭球？（地球也不是完全的椭球体。但是实际上比起球体它是更加接近椭球体。）答案关联到以上提到的其他目标，性能和鲁棒性。椭球体上的操作仍然比球体上的操作慢几个数量级。此外，鲁棒性的几何算法需要实现不受数字误差影响的精确几何谓词。虽然这对于平面几何来说非常简单，而对于球面几何来说有些困难，都不知道如何为椭球体几何实现所有的几何谓词。</p>
<h2 id="S2-Cells"><a href="#S2-Cells" class="headerlink" title="S2 Cells"></a>S2 Cells</h2><p>The S2 library defines a framework for decomposing the unit sphere into a hierarchy of cells. Each cell is a quadrilateral bounded by four geodesics. The top level of the hierarchy is obtained by projecting the six faces of a cube onto the unit sphere, and lower levels are obtained by subdividing each cell into four children recursively. For example, the following image shows two of the six face cells, one of which has been subdivided several times:<br>S2库为了分解一个单位球体为一个分层的cells定义了一个框架。每一个cell是一个由四个测地线限定的四边形。通过将立方体的六个面投影到单位球上来获得这个层次结构的顶层，低层结构则通过递归地切分每个cell为4个子块来获得。例如，以下图片展示了6个面cell的其中2个cell，其中1个已经切分了多次：</p>
<img src="/2019/02/14/Google-S2/images/s2hierarchy.gif" title="This is an example image">
<p>Notice that the cell edges appear to be curved; this is because they are spherical geodesics, i.e., straight lines on the sphere (similar to the routes that airplanes fly).<br>注意cell的边缘是弯曲的；这是因为它们是球形测地线，例如球体上的直线（和飞行航线类似）。</p>
<p>Each cell in the hierarchy has a level, defined as the number of times the cell has been subdivided (starting with a face cell). Cells levels range from 0 to 30. The smallest cells at level 30 are called leaf cells; there are 6 * 430 of them in total, each about 1cm across on the Earth’s surface. (Details on the cell sizes at each level can be found on the S2 Cell Statistics page.)</p>
<p>在这个层次结构中，每个cell都有一个level，定义是这个cell已经被切分的次数（从最顶层的cell开始）。cell的level范围从0到30。最小的cell是level 30的cell，称为leaf cells。它们总共有6 * 4的30次方个，每个是地表上的1厘米。（详细的关于cell各个层级的尺寸请参照这个链接。）</p>
<p>The S2 hierarchy is useful for spatial indexing and for approximating regions as a collection of cells. Cells can be used to represent both points and regions: points are generally represented as leaf cells, while regions are represented as collections of cells at any level(s). For example, here is an approximation of Hawaii as a collection of 22 cells:<br>S2层次结构对于空间索引和划分地区为一个cells的集合是有用的。cells可以用于表示点和区域：点通常表示为叶子cells，而区域是表示为任何层次的cells的集合。例如，这是一个夏威夷作为22个cell的划分：</p>
<img src="/2019/02/14/Google-S2/images/hawaii.gif" title="This is an example image">
<h2 id="S2CellId-Numbering"><a href="#S2CellId-Numbering" class="headerlink" title="S2CellId Numbering"></a>S2CellId Numbering</h2><p>Each cell is uniquely identified by a 64-bit S2CellId. The S2 cells are numbered in a special way in order to maximize locality of reference when they are used for spatial indexing (compared to other methods of numbering the cells).</p>
<p>每个cell是独立地标志为一个64位的S2CellId。S2 cells以特殊方式编号，以便在用于空间索引时最大化参考的位置（与其他编号cell的方法相比）。</p>
<p>In particular, the S2 cells are ordered sequentially along a space-filling curve (a type of fractal). The particular curve used by S2 is called the S2 space-filling curve, and consists of six Hilbert curves linked together to form a single continuous loop over the entire sphere. Here is an illustration of the S2 curve after 5 levels of subdivision:</p>
<p>特别地，S2 cell沿着空间填充曲线（一种分形）顺序排列。这个由S2使用的特别的曲线称为S2空间填充曲线，由连接在一起的六条希尔伯特曲线组成，在整个球体上形成一个连续的环。以下是5级细分后的S2曲线图示：</p>
<img src="/2019/02/14/Google-S2/images/s2curve-small.gif" title="This is an example image">
<p>The yellow curve is an approximation of the S2 space-filling curve. It is a single continuous loop with a fractal structure such that it passes near every point on the sphere. (If you were to cut along the yellow line, it would separate the sphere into two equal halves.) The green lines show the boundaries of the S2 cells at levels 0, 1, 2, 3, 4, and 5, drawn as lines of different widths. (You can click on the image to see a larger version.)</p>
<p>黄色曲线是一个S2空间填充曲线的划分。它是一个单调递增的环，伴随着一个不规则碎片形结构从而让它穿过球体上的每一个点。（如果我你可以沿着黄线切断，将会把球体分为两等分。）这些不同宽度的绿色的线展示了S2 cells在level 0, 1, 2, 3, 4和5的边界。（你可以点击这个图片去看更大的版本。）</p>
<p>The cells at level 5 are numbered in increasing order along this curve. This leads to the property that if the S2CellIds of two cells are close together, then the cells are also close together.1 This property significantly improves locality of reference when the cells are used for indexing.</p>
<p>level 5的cells通过沿着这条曲线的递增的序列编号。这引出一个性质如果两个cells的S2CellIds是接近的，然后这些cells也是接近的。当cells用于建立索引，这条性质显著地改进了参照的局部性。</p>
<p>The remainder of this section gives further details about how the S2 cell hierarchy is organized. (You don’t need to understand this background information in order to use the library – you can skip forward if desired.)</p>
<p>本节的其余部分提供了有关如何组织S2单元层次结构的更多详细信息。</p>
<h2 id="Hilbert-Curve"><a href="#Hilbert-Curve" class="headerlink" title="Hilbert Curve"></a>Hilbert Curve</h2><p>The S2 curve is based on the Hilbert curve. The Hilbert curve is a function from the unit interval [0,1] to the unit square [0,1]×[0,1] that is space-filling, meaning that it visits every point in the unit square. The Hilbert curve is continuous but not differentiable, and can be considered to have infinite length.</p>
<p>S2曲线是基于希尔伯特曲线。希尔伯特曲线是一个函数从单元线段[0,1]到单元方格[0,1]×[0,1]<br>称为空间填充，意味着它将访问单位球体的每一个点。希尔伯特曲线是连续的但是不可微。并能设想为具有无限的长度。</p>
<p>It is most easily defined as the limit of an iterative process that builds a more detailed approximation of the curve at each step. Here is a part of the first page of Hilbert’s 1891 paper defining his curve (cf.Mark McClure ):</p>
<p>一步步地构建一个更加详细的曲线划分的迭代过程的限制是非常简单的定义。这是论文的第一页的一个部分。</p>
<img src="/2019/02/14/Google-S2/images/hilbert-figure.gif" title="This is an example image">
<p>As you can see, the first iteration divides the unit square into 4 smaller squares. The curve visits those squares in a particular order that looks like an inverted “U” (figure 1). The second iteration takes each square from the first iteration and divides it into 4 smaller subsquares. The curve again visits those subsquares in a U-shaped order, except that some of the U-shapes have been rotated and/or reflected in order to link the curves together seamlessly (figure 2). (The rotation/reflection rules are simple but we will not describe them here.) Figure 3 shows the result after three iterations.</p>
<p>正如你能看到的，第一次迭代划分这个单位方块为4个更小的方块。这个曲线按照一定的顺序，看上去像一个反转的“U”，访问这些方块。第二次迭代从第一次迭代中取出每个方块，然后划分它为4个更小的子方块。这个曲线按照U形顺序再次访问这些子方块，除了一些U形已经被翻转或者反射来连接曲线到一块。（翻转、反射规则很简单但是我们将不会在这里描述。）图3展示了三次迭代的结果。</p>
<p>How does this process define a mapping from the unit interval to the unit square? Let<br>H : [0,1] → [0,1] × [0,1]<br>be the Hilbert curve, and suppose that we want to evaluate H(s) for the real number s = 0.5. We start by writing out the binary expansion of s = 0.5:<br>s = 0.100000000…<br>To find the corresponding point H(s) on the Hilbert curve, we group the digits of “s” into pairs:<br>[10, 00, 00, 00, …]</p>
<p>这个过程如何定义一个从单位线段到单位方块的映射？想让：<br>H : [0,1] → [0,1] × [0,1]<br>成为希尔伯特曲线，假设我们想为实数s=0.5估算H(s)的值。我们从写出s=0.5的二进制扩展开始：<br>s = 0.100000000…<br>为了找到相应的点，我们将”s”的位划分为多对：<br>[10, 00, 00, 00, …]</p>
<p>Each pair of binary digits corresponds to a decimal number between 0 and 3, and indicates which of the 4 subsquares to choose at each step of the construction process. Note that unlike Hilbert’s paper, we number the subsquares of each square from 0 to 3 (in the order they are visited by the curve) rather than 1 to 4. For example, in the case of s = 0.5, the first group of digits “10” corresponds to the decimal number 2, which means that we choose subsquare 2 during the first iteration (i.e., square 3 in Hilbert’s figure 1). The next group of digits is “00”, meaning that we choose subsquare 0 during the second iteration (corresponding to square 9 in Hilbert’s figure 2). Continuing in this way, for s = 0.5 the result looks something like this:</p>
<p>每一对二进制数位对应一个0-3的十进制数字。表示4个子方块在构建的每一步如何选择。注意，不像希伯尔特的论文，我们从0到3编号每一个方块（按照它们在曲线上被访问的顺序）而不是从1到4。例如，s=0.5的情况，第一组数位“10”对应十进制数字2，表示在第一次迭代中我们选择子方块2（如图1的方块3）。下一组数位是“00”，意味着第二次迭代中我们选择子方块0（对应图2的方块9）。继续这个过程，对于s=0.5的结果将是如此：</p>
<img src="/2019/02/14/Google-S2/images/hilbert-cell-center.gif" title="This is an example image">
<p>In the limit, this process converges to a point that is exactly at the center of the square (the green dot in the figure). This implies that<br>H(0.5) = (0.5, 0.5)<br>i.e., the midpoint of the Hilbert curve is at the exact center of unit square.2 The value of H(s) for any real number “s” can be evaluated using a similar process.</p>
<p>在这个限制中，这个过程转换为一个准确地位于方格中心的点（图中的绿点）。这表明：<br>H(0.5) = (0.5, 0.5)<br>例如，希伯尔特曲线的中点是方块2的中心。对于任何实数s，H(s)的值可以使用相同的过程估算。</p>
<h2 id="S2-Space-Filling-Curve"><a href="#S2-Space-Filling-Curve" class="headerlink" title="S2 Space-Filling Curve"></a>S2 Space-Filling Curve</h2><p>The S2 space-filling curve is a function<br>S : [0,6] → S²<br>i.e., from the interval [0,6] to the unit sphere. It is constructed by mapping 6 copies of the Hilbert curve to the 6 faces of a unit cube, reflecting and rotating the curves as necessary so that that they link together seamlessly into a continuous loop. The cube is then mapped to the unit sphere using a transformation that minimizes distortion.<br>We can view the S2 curve parameter “s” as having the format:<br>s = [face].[face_pos]<br>where “face” is a number in the range [0..5] that selects one of the six cube faces, and “face_pos” is the Hilbert curve parameter on that face. This mapping is defined such that the end of the curve on face i exactly matches the start of the curve on face i+1 (including the transition from face 5 to face 0).<br>Here is an illustration (not fully accurate, but conceptually correct) of the S2 curve on the unit cube (before projecting it to the sphere). The cube has been unfolded and flattened, and shows the first 4 levels of the S2 curve subdivision:</p>
<p>S2空间填充曲线是一个函数：<br>S : [0,6] → S²<br>例如，从线段[0,6]到单元球。通过映射希伯尔特曲线到单位立方体的6个面的6份拷贝，反射和翻转曲线以此它们能无缝地连接在一起成为一个连续的环。然后立方体通过使用最小化失真转换映射到单位球体。我们能按照如下格式访问S2曲线的参数“s”：<br>s = [face].[face_pos]<br>面是0-5的数字，选择立方体6个面的其中之一。“face_pos” 是希伯尔特曲线在这个面的参数。这个映射定义为在面i曲线的末端准确地匹配面i+1的曲线起始位置（包括从面5到面0的转变）。<br>这是一个S2曲线在单位立方体（在将它投影到球体上）上的插图（不完全准确的，但是概念上是对的）。立方体已经展开并展平，展示了S2曲线的level 4划分：</p>

<p>(Larger images of the individual faces can be found here.) Note that the traversal order of the odd-numbered faces is the mirror image of the even-numbered faces.<br>When the cube is mapped onto the unit sphere, the result is the curve shown earlier:<br>（更大的独立的面的图片可以在这里找到。）注意，遍历顺序中奇数面是偶数面的反射。当立方体映射为单位球体，结果如之前展示的那样：</p>
<img src="/2019/02/14/Google-S2/images/s2curve-tiny.gif" title="This is an example image">
<h2 id="S2CellId-Numbering-again"><a href="#S2CellId-Numbering-again" class="headerlink" title="S2CellId Numbering (again)"></a>S2CellId Numbering (again)</h2><p>We now return to the question of how the S2 cells are numbered. Recall that there are 31 levels of subdivision, ranging from 0 to 30. It turns out that the cell numbering system at all levels follows a very simple rule, namely:<br>The S2CellId of cell C is the S2 curve parameter at the center of C (scaled to obtain an integer).<br>For example, consider the level 0 cell for cube face 2. The center of this cell has the S2 curve parameter (in binary):<br>s = 010.100000000…<br>where “010” is the binary representation of face 2 and “.1000…” is the binary representation of 0.5 (i.e., the Hilbert curve parameter at the center of this face, as discussed above). Scaling this by a factor of 261, we obtain 0101000… in binary (where there are 60 trailing zeros), or 0x5000000000000000 in hexadecimal. This is the S2CellId for the level 0 cell on face 2.</p>
<p>我们现在回到S2 cells如何编号的问题上。召回划分的31个level，从0到30。事实证明cell的编号系统在各个level遵循一个非常简单的规则，即：<br>cell C的S2CellId是S2曲线在C的中心参数（以此获得一个整数）。<br>例如，考虑立方体face 2的level 0 cell。这个cell的中心有S2曲线参数（二进制）：<br>s = 010.100000000…<br>“010”是二进制表示face 2，而“.1000…”是0.5的二进制形式（例如，正如上面所述，在这个面的中心的希尔伯特曲线参数）。将其缩放261倍，我们得到0101000…（有60个尾随零），或者十六进制0x5000000000000000。这是face 2的level 0 cell的S2CellId。</p>
<p>It turns out that all S2CellIds up to level 30 can be represented in this way, i.e. the S2 curve parameters of the corresponding cell centers can be represented exactly in 64 bits. Note that no two cells (even at different levels) have the same center position, and therefore all the S2CellIds are distinct. The cell center is sufficient to specify both the position and the subdivision level of each cell.<br>We can also look at this from a more practical point of view. The S2CellId for a cell at level k always has the following structure:<br>s = [face] [child]k 1 060-2k<br>where “face” is a 3-bit number (range 0..5) that selects a cube face, and each of the k “child” values is a 2-bit number that selects one of the 4 children during the subdivision process. The bit that follows the last child is always 1, and all other bits are zero. For example:</p>
<p>事实证明上至level 30的所有S2CellIds能按照这个方式表示。例如对应cell中心的S2曲线参数能准确地表示为64位数字。注意，没有两个cells（甚至是不同level的）有着相同中心。所以所有的S2CellIds是唯一的。cell的中心足够指定每一个cell的位置和层级划分。<br>我们也可以从更实际的角度来看待这个问题。在level k的cell的S2CellId总是这样的结构：<br>s = [face] [child]k 1 060-2k<br>“face” 是3比特的数字（0-5）以此选择一个立方体的面，每一个k的“child”值是一个2比特的数字以此在划分过程中选择4个子cells中的其中一个。最后一个孩子的bit总是1，所有其他的比特是0。例如：<br>010 10000…0         Face cell 2.<br>001 10 100…0        Subcell 2 of face cell 1.<br>100 11 01 1000…0    Subcell 1 of subcell 3 of face 4.</p>
<p>This representation has the convenient property that the subdivision level of a cell can easily be determined from the position of its lowest-numbered 1 bit.</p>
<p>这种表示对于划分一个cell的level能简单地定义为它的最小数位1比特的位置很方便。</p>
<h2 id="Coordinate-Systems"><a href="#Coordinate-Systems" class="headerlink" title="Coordinate Systems"></a>Coordinate Systems</h2><p>The process of mapping an S2CellId to a point on the unit sphere involves several steps, each with its own coordinate system.<br>映射一个S2CellId到一个单位球体的点的过程包含着若干步骤，每一个都它自己的坐标系。</p>
<p>(cellid)<br>Cell id: A 64-bit encoding of a face and a Hilbert curve parameter on that face, as discussed above. The Hilbert curve parameter implicitly encodes both the position of a cell and its subdivision level.</p>
<p>cellid<br>Cell id：正如以上所述，是一个1个face和1个那个面的希尔伯特曲线参数的64位的编码。希尔伯特曲线参数暗中编码了一个cell的位置和它的划分层级。</p>
<p>(face, i, j)\ Leaf-cell coordinates: The leaf cells are the subsquares that result after 30 levels of Hilbert curve subdivision, consisting of a 230 × 230 array on each face. “i” and “j” are integers in the range [0, 230-1] that identify a particular leaf cell. The (i, j) coordinate system is right-handed on every face, and the faces are oriented such that Hilbert curves connect continuously from one face to the next.</p>
<p>(face, i, j)\叶子cell的坐标：叶子cell是希伯尔特曲线30个level划分后产生的子块。包含一个230x230的数组。i和j是一个范围是[0, 230-1]的整数，唯一地表示一个特定的叶子cell。(i,j)坐标系是右手坐标系。face是毗邻的，以致于希伯尔特曲线连续地连接每一个面。</p>
<p>(face, s, t)\ Cell-space coordinates: “s” and “t” are real numbers in the range [0,1] that identify a point on the given face. For example, the point (s, t) = (0.5, 0.5) corresponds to the center of the cell at level 0. Cells in (s, t)-coordinates are perfectly square and subdivided around their center point, just like the Hilbert curve construction.</p>
<p>(face, s, t)\cell-空间坐标：s和t是范围0-1的实数表示一个给定的face的一个点。例如，点(s,t)=(0.5,0.5)对应level 0的cell的中心。cell在(s,t)-坐标是完全正方形的和划分他们的中心点，正如希伯尔特曲线构建过程那样。</p>
<p>(face, u, v)\ Cube-space coordinates: To make the cells at each level more uniform in size after they are projected onto the sphere, we apply a nonlinear transformation of the form u=f(s), v=f(t) before projecting points onto the sphere. This function also scales the (u,v)-coordinates so that each face covers the biunit square [-1,1]×[-1,1]. Cells in (u,v)-coordinates are rectangular, and are not necessarily subdivided around their center point (because of the nonlinear transformation “f”).</p>
<p>范围(face, u, v)\ 立方体空间坐标系：为了让每个level的cells在它们投影到球面上后，尺寸上更加统一，在投影点到球面之前，我们申请一个以u=f(s), v=f(t)的形式的非线性转换。这个函数也缩放(u,v)-坐标系从而每一个face覆盖单位正方形[-1,1]×[-1,1]。cells的(u,v)-坐标是矩形的，并且不一定围绕它们的中心点细分</p>
<p>(x, y, z)\ Spherical point: The final S2Point is obtained by projecting the (face, u, v) coordinates onto the unit sphere. Cells in (x,y,z)-coordinates are quadrilaterals bounded by four spherical geodesic edges.</p>
<p>(x, y, z)\球面点：最后的S2Point是通过投影(face, u, v)坐标到单位球体。(x, y, z)的cell坐标系是由四个球形测地边界限定的四边形。</p>
<p>The purpose of the nonlinear (face, s, t) → (face, u, v) transformation is to make the cells roughly the same size on the sphere. This can be visualized as follows:</p>
<p>(face, s, t) → (face, u, v)的非线性转换的目的是为了让cells在球体上有着同样的大小。这个转换如下展示：</p>
<img src="/2019/02/14/Google-S2/images/xyz_to_uv_to_st.gif" title="This is an example image">
<p>{height=”400”}<br>This diagram shows a one-dimensional slice of cube face. Starting from the right-hand size, an s- or t-coordinate in the range [0,1] is transformed non-linearly into a u- or v-coordinate in the range [-1,1]. This point is then projected onto the unit sphere.<br>The purpose of the (face, s, t)→(face, u, v) transformation is illustrated by the two angles marked in red. Although both angles are the same size, and therefore correspond to the same distance on the unit sphere, they have very different sizes when projected back to (u,v)-coordinates (i.e., the top interval on the middle (u,v)-slice is much larger). The non-linear transformation between (s,t) and (u,v) coordinates helps to correct this situation (i.e., the intervals on the right-hand (s,t)-slice are closer in size).<br>Note that the (i, j), (s, t), and (u, v) coordinate systems are right-handed on all six faces.</p>
<p>这个图表展示了一个一维的立方体face的分片。从右手坐标系的尺寸开始，一个范围0-1是s或者t的坐标通过非线性转换转换为范围是[-1,1]的u v坐标。然后这个点投影到单位球体。<br>(face, s, t) → (face, u, v)的转换目的是如图解所示的2个红色标出的角。虽然两个角有着相同的大小，对应着单位球体的相同距离。但是当投影回(u,v)坐标，他们有着非常不同的尺寸。（例如，最顶层的在(u,v)中间分片的线段是要大得多）。(s,t) 和 (u,v)的非线性转换有益于矫正这个条件。（例如，右手坐标(s,t)分片更接近这个尺寸）。<br>注意，(i, j), (s, t)和(u,v)坐标系在6个面是右手坐标系。</p>
<h2 id="S2CellId"><a href="#S2CellId" class="headerlink" title="S2CellId"></a>S2CellId</h2><p>The S2CellId class is a thin wrapper over the 64-bit S2CellId number that provides methods for navigating the cell hierarchy (finding parents, children, containment tests, etc). Since leaf cells are often used to represent points on the unit sphere, the S2CellId class also provides methods for converting directly to and from an S2Point. Here are its methods:</p>
<p>S2CellId类是一个薄包装的64位S2CellId数字，为导航cell层次结构（查找父母cell和孩子cell的包含测试）提供方法。叶cell经常用于表示球面的点，S2CellId类也提供将S2Point直接转换的方法。这是它的方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S2CellId</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kFaceBits = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kNumFaces = <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kMaxLevel = <span class="number">30</span>;  <span class="comment">// Valid levels: 0..kMaxLevel</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kMaxSize = <span class="number">1</span> &lt;&lt; kMaxLevel;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Although only 60 bits are needed to represent the index of a leaf</span></span><br><span class="line">  <span class="comment">// cell, we need an extra bit in order to represent the position of</span></span><br><span class="line">  <span class="comment">// the center of the leaf cell along the Hilbert curve.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kPosBits = <span class="number">2</span> * kMaxLevel + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">S2CellId</span><span class="params">(uint64 id)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The default constructor returns an invalid cell id.</span></span><br><span class="line">  S2CellId();</span><br><span class="line">  <span class="function"><span class="keyword">static</span> S2CellId <span class="title">None</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return an invalid cell id guaranteed to be larger than any</span></span><br><span class="line">  <span class="comment">// valid cell id.  Useful for creating indexes.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> S2CellId <span class="title">Sentinel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the cell corresponding to a given S2 cube face.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> S2CellId <span class="title">FromFace</span><span class="params">(<span class="keyword">int</span> face)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return a cell given its face (range 0..5), Hilbert curve position within</span></span><br><span class="line">  <span class="comment">// that face (an unsigned integer with S2CellId::kPosBits bits), and level</span></span><br><span class="line">  <span class="comment">// (range 0..kMaxLevel).  The given position will be modified to correspond</span></span><br><span class="line">  <span class="comment">// to the Hilbert curve position at the center of the returned cell.  This</span></span><br><span class="line">  <span class="comment">// is a static function rather than a constructor in order to indicate what</span></span><br><span class="line">  <span class="comment">// the arguments represent.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> S2CellId <span class="title">FromFacePosLevel</span><span class="params">(<span class="keyword">int</span> face, uint64 pos, <span class="keyword">int</span> level)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Construct a leaf cell containing the given point "p".  Usually there is</span></span><br><span class="line">  <span class="comment">// exactly one such cell, but for points along the edge of a cell, any</span></span><br><span class="line">  <span class="comment">// adjacent cell may be (deterministically) chosen.  This is because</span></span><br><span class="line">  <span class="comment">// S2CellIds are considered to be closed sets.  The returned cell will</span></span><br><span class="line">  <span class="comment">// always contain the given point, i.e.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//   S2Cell(S2CellId(p)).Contains(p)</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// is always true.  The point "p" does not need to be normalized.</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">S2CellId</span><span class="params">(<span class="keyword">const</span> S2Point&amp; p)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Construct a leaf cell containing the given normalized S2LatLng.</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">S2CellId</span><span class="params">(<span class="keyword">const</span> S2LatLng&amp; ll)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the direction vector corresponding to the center of the given</span></span><br><span class="line">  <span class="comment">// cell.  The vector returned by ToPointRaw is not necessarily unit length.</span></span><br><span class="line">  <span class="comment">// This method returns the same result as S2Cell::GetCenter().</span></span><br><span class="line">  <span class="function">S2Point <span class="title">ToPoint</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">S2Point <span class="title">ToPointRaw</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the S2LatLng corresponding to the center of the given cell.</span></span><br><span class="line">  <span class="function">S2LatLng <span class="title">ToLatLng</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The 64-bit unique identifier for this cell.</span></span><br><span class="line">  <span class="function">uint64 <span class="title">id</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return true if id() represents a valid cell.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">is_valid</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Which cube face this cell belongs to, in the range 0..5.</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">face</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The position of the cell center along the Hilbert curve over this face,</span></span><br><span class="line">  <span class="comment">// in the range 0..(2^kPosBits-1).</span></span><br><span class="line">  <span class="function">uint64 <span class="title">pos</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the subdivision level of the cell (range 0..kMaxLevel).</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">level</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return true if this is a leaf cell (more efficient than checking</span></span><br><span class="line">  <span class="comment">// whether level() == kMaxLevel).</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">is_leaf</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return true if this is a top-level face cell (more efficient than</span></span><br><span class="line">  <span class="comment">// checking whether level() == 0).</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">is_face</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the child position (0..3) of this cell within its parent.</span></span><br><span class="line">  <span class="comment">// REQUIRES: level() &gt;= 1.</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">child_position</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the child position (0..3) of this cell's ancestor at the given</span></span><br><span class="line">  <span class="comment">// level within its parent.  For example, child_position(1) returns the</span></span><br><span class="line">  <span class="comment">// position of this cell's level-1 ancestor within its top-level face cell.</span></span><br><span class="line">  <span class="comment">// REQUIRES: 1 &lt;= level &lt;= this-&gt;level().</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">child_position</span><span class="params">(<span class="keyword">int</span> level)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Methods that return the range of cell ids that are contained</span></span><br><span class="line">  <span class="comment">// within this cell (including itself).  The range is *inclusive*</span></span><br><span class="line">  <span class="comment">// (i.e. test using &gt;= and &lt;=) and the return values of both</span></span><br><span class="line">  <span class="comment">// methods are valid leaf cell ids.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// These methods should not be used for iteration.  If you want to</span></span><br><span class="line">  <span class="comment">// iterate through all the leaf cells, call child_begin(kMaxLevel) and</span></span><br><span class="line">  <span class="comment">// child_end(kMaxLevel) instead.  Also see maximum_tile(), which can be used</span></span><br><span class="line">  <span class="comment">// to iterate through cell ranges using cells at different levels.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// It would in fact be error-prone to define a range_end() method, because</span></span><br><span class="line">  <span class="comment">// this method would need to return (range_max().id() + 1) which is not</span></span><br><span class="line">  <span class="comment">// always a valid cell id.  This also means that iterators would need to be</span></span><br><span class="line">  <span class="comment">// tested using "&lt;" rather that the usual "!=".</span></span><br><span class="line">  <span class="function">S2CellId <span class="title">range_min</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">S2CellId <span class="title">range_max</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return true if the given cell is contained within this one.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(S2CellId other)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return true if the given cell intersects this one.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">intersects</span><span class="params">(S2CellId other)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the cell at the previous level or at the given level (which must</span></span><br><span class="line">  <span class="comment">// be less than or equal to the current level).</span></span><br><span class="line">  <span class="function">S2CellId <span class="title">parent</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">S2CellId <span class="title">parent</span><span class="params">(<span class="keyword">int</span> level)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the immediate child of this cell at the given traversal order</span></span><br><span class="line">  <span class="comment">// position (in the range 0 to 3).  This cell must not be a leaf cell.</span></span><br><span class="line">  <span class="function">S2CellId <span class="title">child</span><span class="params">(<span class="keyword">int</span> position)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Iterator-style methods for traversing the immediate children of a cell or</span></span><br><span class="line">  <span class="comment">// all of the children at a given level (greater than or equal to the current</span></span><br><span class="line">  <span class="comment">// level).  Note that the end value is exclusive, just like standard STL</span></span><br><span class="line">  <span class="comment">// iterators, and may not even be a valid cell id.  You should iterate using</span></span><br><span class="line">  <span class="comment">// code like this:</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//   for(S2CellId c = id.child_begin(); c != id.child_end(); c = c.next())</span></span><br><span class="line">  <span class="comment">//     ...</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The convention for advancing the iterator is "c = c.next()" rather</span></span><br><span class="line">  <span class="comment">// than "++c" to avoid possible confusion with incrementing the</span></span><br><span class="line">  <span class="comment">// underlying 64-bit cell id.</span></span><br><span class="line">  <span class="function">S2CellId <span class="title">child_begin</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">S2CellId <span class="title">child_begin</span><span class="params">(<span class="keyword">int</span> level)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">S2CellId <span class="title">child_end</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">S2CellId <span class="title">child_end</span><span class="params">(<span class="keyword">int</span> level)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the next/previous cell at the same level along the Hilbert curve.</span></span><br><span class="line">  <span class="comment">// Works correctly when advancing from one face to the next, but</span></span><br><span class="line">  <span class="comment">// does *not* wrap around from the last face to the first or vice versa.</span></span><br><span class="line">  <span class="function">S2CellId <span class="title">next</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">S2CellId <span class="title">prev</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This method advances or retreats the indicated number of steps along the</span></span><br><span class="line">  <span class="comment">// Hilbert curve at the current level, and returns the new position.  The</span></span><br><span class="line">  <span class="comment">// position is never advanced past End() or before Begin().</span></span><br><span class="line">  <span class="function">S2CellId <span class="title">advance</span><span class="params">(int64 steps)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the level of the "lowest common ancestor" of this cell and</span></span><br><span class="line">  <span class="comment">// "other".  Note that because of the way that cell levels are numbered,</span></span><br><span class="line">  <span class="comment">// this is actually the *highest* level of any shared ancestor.  Return -1</span></span><br><span class="line">  <span class="comment">// if the two cells do not have any common ancestor (i.e., they are from</span></span><br><span class="line">  <span class="comment">// different faces).</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">GetCommonAncestorLevel</span><span class="params">(S2CellId other)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Iterator-style methods for traversing all the cells along the Hilbert</span></span><br><span class="line">  <span class="comment">// curve at a given level (across all 6 faces of the cube).  Note that the</span></span><br><span class="line">  <span class="comment">// end value is exclusive (just like standard STL iterators), and is not a</span></span><br><span class="line">  <span class="comment">// valid cell id.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> S2CellId <span class="title">Begin</span><span class="params">(<span class="keyword">int</span> level)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> S2CellId <span class="title">End</span><span class="params">(<span class="keyword">int</span> level)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Methods to encode and decode cell ids to compact text strings suitable</span></span><br><span class="line">  <span class="comment">// for display or indexing.  Cells at lower levels (i.e. larger cells) are</span></span><br><span class="line">  <span class="comment">// encoded into fewer characters.  The maximum token length is 16.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// ToToken() returns a string by value for convenience; the compiler</span></span><br><span class="line">  <span class="comment">// does this without intermediate copying in most cases.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// These methods guarantee that FromToken(ToToken(x)) == x even when</span></span><br><span class="line">  <span class="comment">// "x" is an invalid cell id.  All tokens are alphanumeric strings.</span></span><br><span class="line">  <span class="comment">// FromToken() returns S2CellId::None() for malformed inputs.</span></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">ToToken</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> S2CellId <span class="title">FromToken</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* token, <span class="keyword">size_t</span> length)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> S2CellId <span class="title">FromToken</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; token)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Creates a debug human readable string. Used for &lt;&lt; and available for direct</span></span><br><span class="line">  <span class="comment">// usage as well.</span></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">ToString</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the four cells that are adjacent across the cell's four edges.</span></span><br><span class="line">  <span class="comment">// Neighbors are returned in the order defined by S2Cell::GetEdge.  All</span></span><br><span class="line">  <span class="comment">// neighbors are guaranteed to be distinct.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">GetEdgeNeighbors</span><span class="params">(S2CellId neighbors[<span class="number">4</span>])</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the neighbors of closest vertex to this cell at the given level,</span></span><br><span class="line">  <span class="comment">// by appending them to "output".  Normally there are four neighbors, but</span></span><br><span class="line">  <span class="comment">// the closest vertex may only have three neighbors if it is one of the 8</span></span><br><span class="line">  <span class="comment">// cube vertices.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Requires: level &lt; this-&gt;level(), so that we can determine which vertex is</span></span><br><span class="line">  <span class="comment">// closest (in particular, level == kMaxLevel is not allowed).</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AppendVertexNeighbors</span><span class="params">(<span class="keyword">int</span> level, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;S2CellId&gt;* output)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Append all neighbors of this cell at the given level to "output".  Two</span></span><br><span class="line">  <span class="comment">// cells X and Y are neighbors if their boundaries intersect but their</span></span><br><span class="line">  <span class="comment">// interiors do not.  In particular, two cells that intersect at a single</span></span><br><span class="line">  <span class="comment">// point are neighbors.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Requires: nbr_level &gt;= this-&gt;level().  Note that for cells adjacent to a</span></span><br><span class="line">  <span class="comment">// face vertex, the same neighbor may be appended more than once.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AppendAllNeighbors</span><span class="params">(<span class="keyword">int</span> nbr_level, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;S2CellId&gt;* output)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>See s2cellid.h for additional methods.<br>s2cellid.h可以看到更多的方法。</p>
<h2 id="S2Cell"><a href="#S2Cell" class="headerlink" title="S2Cell"></a>S2Cell</h2><p>An S2Cell is an S2Region object that represents a cell. Unlike S2CellId, it views a cell as a representing a spherical quadrilateral rather than a point, and it supports efficient containment and intersection tests. However, it is also a more expensive representation (currently 48 bytes rather than 8).<br>Here are its methods:</p>
<p>一个S2Cell是一个表示一个cell的S2Region对象。和S2CellId不同的是，它访问一个cell如同表示一个球面四边形而不是一个点。它支持有效率的包含和交集测试。然而，它也是一个更加代价高昂的表示形式（目前是48字节而不是8字节）。<br>这里是它的方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S2Cell</span> <span class="title">final</span> :</span> <span class="keyword">public</span> S2Region &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// The default constructor is required in order to use freelists.</span></span><br><span class="line">  <span class="comment">// Cells should otherwise always be constructed explicitly.</span></span><br><span class="line">  S2Cell();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An S2Cell always corresponds to a particular S2CellId.  The other</span></span><br><span class="line">  <span class="comment">// constructors are just convenience methods.</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">S2Cell</span><span class="params">(S2CellId id)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Convenience constructors.  The S2LatLng must be normalized.</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">S2Cell</span><span class="params">(<span class="keyword">const</span> S2Point&amp; p)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">S2Cell</span><span class="params">(<span class="keyword">const</span> S2LatLng&amp; ll)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the cell corresponding to the given S2 cube face.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> S2Cell <span class="title">FromFace</span><span class="params">(<span class="keyword">int</span> face)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return a cell given its face (range 0..5), Hilbert curve position within</span></span><br><span class="line">  <span class="comment">// that face (an unsigned integer with S2CellId::kPosBits bits), and level</span></span><br><span class="line">  <span class="comment">// (range 0..kMaxLevel).  The given position will be modified to correspond</span></span><br><span class="line">  <span class="comment">// to the Hilbert curve position at the center of the returned cell.  This</span></span><br><span class="line">  <span class="comment">// is a static function rather than a constructor in order to indicate what</span></span><br><span class="line">  <span class="comment">// the arguments represent.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> S2Cell <span class="title">FromFacePosLevel</span><span class="params">(<span class="keyword">int</span> face, uint64 pos, <span class="keyword">int</span> level)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">S2CellId <span class="title">id</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">face</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">level</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">orientation</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">is_leaf</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the k-th vertex of the cell (k = 0,1,2,3).  Vertices are returned</span></span><br><span class="line">  <span class="comment">// in CCW order (lower left, lower right, upper right, upper left in the UV</span></span><br><span class="line">  <span class="comment">// plane).  The points returned by GetVertexRaw are not normalized.</span></span><br><span class="line">  <span class="function">S2Point <span class="title">GetVertex</span><span class="params">(<span class="keyword">int</span> k)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">S2Point <span class="title">GetVertexRaw</span><span class="params">(<span class="keyword">int</span> k)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the inward-facing normal of the great circle passing through</span></span><br><span class="line">  <span class="comment">// the edge from vertex k to vertex k+1 (mod 4).  The normals returned</span></span><br><span class="line">  <span class="comment">// by GetEdgeRaw are not necessarily unit length.</span></span><br><span class="line">  <span class="function">S2Point <span class="title">GetEdge</span><span class="params">(<span class="keyword">int</span> k)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">S2Point <span class="title">GetEdgeRaw</span><span class="params">(<span class="keyword">int</span> k)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If this is not a leaf cell, set children[0..3] to the four children of</span></span><br><span class="line">  <span class="comment">// this cell (in traversal order) and return true.  Otherwise returns false.</span></span><br><span class="line">  <span class="comment">// This method is equivalent to the following:</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// for (pos=0, id=child_begin(); id != child_end(); id = id.next(), ++pos)</span></span><br><span class="line">  <span class="comment">//   children[pos] = S2Cell(id);</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// except that it is more than two times faster.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Subdivide</span><span class="params">(S2Cell children[<span class="number">4</span>])</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the direction vector corresponding to the center in (s,t)-space of</span></span><br><span class="line">  <span class="comment">// the given cell.  This is the point at which the cell is divided into four</span></span><br><span class="line">  <span class="comment">// subcells; it is not necessarily the centroid of the cell in (u,v)-space</span></span><br><span class="line">  <span class="comment">// or (x,y,z)-space.  The point returned by GetCenterRaw is not necessarily</span></span><br><span class="line">  <span class="comment">// unit length.</span></span><br><span class="line">  <span class="function">S2Point <span class="title">GetCenter</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">S2Point <span class="title">GetCenterRaw</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the average area for cells at the given level.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">AverageArea</span><span class="params">(<span class="keyword">int</span> level)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the average area of cells at this level.  This is accurate to</span></span><br><span class="line">  <span class="comment">// within a factor of 1.7 (for S2_QUADRATIC_PROJECTION) and is extremely</span></span><br><span class="line">  <span class="comment">// cheap to compute.</span></span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">AverageArea</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the approximate area of this cell.  This method is accurate to</span></span><br><span class="line">  <span class="comment">// within 3% percent for all cell sizes and accurate to within 0.1% for</span></span><br><span class="line">  <span class="comment">// cells at level 5 or higher (i.e. squares 350km to a side or smaller</span></span><br><span class="line">  <span class="comment">// on the Earth's surface).  It is moderately cheap to compute.</span></span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">ApproxArea</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the area of this cell as accurately as possible.  This method is</span></span><br><span class="line">  <span class="comment">// more expensive but it is accurate to 6 digits of precision even for leaf</span></span><br><span class="line">  <span class="comment">// cells (whose area is approximately 1e-18).</span></span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">ExactArea</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the distance from the cell to the given point.  Returns zero if</span></span><br><span class="line">  <span class="comment">// the point is inside the cell.</span></span><br><span class="line">  <span class="function">S1ChordAngle <span class="title">GetDistance</span><span class="params">(<span class="keyword">const</span> S2Point&amp; target)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the distance from the cell boundary to the given point.</span></span><br><span class="line">  <span class="function">S1ChordAngle <span class="title">GetBoundaryDistance</span><span class="params">(<span class="keyword">const</span> S2Point&amp; target)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the minimum distance from the cell to the given edge AB.  Returns</span></span><br><span class="line">  <span class="comment">// zero if the edge intersects the cell interior.</span></span><br><span class="line">  <span class="function">S1ChordAngle <span class="title">GetDistance</span><span class="params">(<span class="keyword">const</span> S2Point&amp; a, <span class="keyword">const</span> S2Point&amp; b)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">////////////////////////////////////////////////////////////////////////</span></span><br><span class="line">  <span class="comment">// S2Region interface (see s2region.h for details):</span></span><br><span class="line"></span><br><span class="line">  <span class="function">S2Cell* <span class="title">Clone</span><span class="params">()</span> <span class="keyword">const</span> override</span>;</span><br><span class="line">  <span class="function">S2Cap <span class="title">GetCapBound</span><span class="params">()</span> <span class="keyword">const</span> override</span>;</span><br><span class="line">  <span class="function">S2LatLngRect <span class="title">GetRectBound</span><span class="params">()</span> <span class="keyword">const</span> override</span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Contains</span><span class="params">(<span class="keyword">const</span> S2Cell&amp; cell)</span> <span class="keyword">const</span> override</span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">MayIntersect</span><span class="params">(<span class="keyword">const</span> S2Cell&amp; cell)</span> <span class="keyword">const</span> override</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return true if the cell contains the given point "p".  Note that unlike</span></span><br><span class="line">  <span class="comment">// S2Loop/S2Polygon, S2Cells are considered to be closed sets.  This means</span></span><br><span class="line">  <span class="comment">// that points along an S2Cell edge (or at a vertex) belong to the adjacent</span></span><br><span class="line">  <span class="comment">// cell(s) as well.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// If instead you want every point to be contained by exactly one S2Cell,</span></span><br><span class="line">  <span class="comment">// you will need to convert the S2Cells to S2Loops (which implement point</span></span><br><span class="line">  <span class="comment">// containment this way).</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The point "p" does not need to be normalized.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Contains</span><span class="params">(<span class="keyword">const</span> S2Point&amp; p)</span> <span class="keyword">const</span> override</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>See s2cell.h for additional methods.<br>s2cell.h可以看到更多的方法。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/28/B树/" rel="next" title="B树-C++实现">
                <i class="fa fa-chevron-left"></i> B树-C++实现
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/02/20/alibaba-inke-rank/" rel="prev" title="阿里、映客职级对应">
                阿里、映客职级对应 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">小益</p>
              <p class="site-description motion-element" itemprop="description">开发，C++工程师</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#概览"><span class="nav-number">1.</span> <span class="nav-text">概览</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#S2-Cells"><span class="nav-number">2.</span> <span class="nav-text">S2 Cells</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#S2CellId-Numbering"><span class="nav-number">3.</span> <span class="nav-text">S2CellId Numbering</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hilbert-Curve"><span class="nav-number">4.</span> <span class="nav-text">Hilbert Curve</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#S2-Space-Filling-Curve"><span class="nav-number">5.</span> <span class="nav-text">S2 Space-Filling Curve</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#S2CellId-Numbering-again"><span class="nav-number">6.</span> <span class="nav-text">S2CellId Numbering (again)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Coordinate-Systems"><span class="nav-number">7.</span> <span class="nav-text">Coordinate Systems</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#S2CellId"><span class="nav-number">8.</span> <span class="nav-text">S2CellId</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#S2Cell"><span class="nav-number">9.</span> <span class="nav-text">S2Cell</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小益</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.0.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.0"></script>

  <script src="/js/src/motion.js?v=7.0.0"></script>



  
  


  <script src="/js/src/schemes/muse.js?v=7.0.0"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.0"></script>
<script src="/js/src/post-details.js?v=7.0.0"></script>



  


  <script src="/js/src/bootstrap.js?v=7.0.0"></script>


  
  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
